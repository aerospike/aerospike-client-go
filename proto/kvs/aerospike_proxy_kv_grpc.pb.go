// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.12.4
// source: proto/kvs/aerospike_proxy_kv.proto

package kvs

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	About_Get_FullMethodName = "/About/Get"
)

// AboutClient is the client API for About service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AboutClient interface {
	Get(ctx context.Context, in *AboutRequest, opts ...grpc.CallOption) (*AboutResponse, error)
}

type aboutClient struct {
	cc grpc.ClientConnInterface
}

func NewAboutClient(cc grpc.ClientConnInterface) AboutClient {
	return &aboutClient{cc}
}

func (c *aboutClient) Get(ctx context.Context, in *AboutRequest, opts ...grpc.CallOption) (*AboutResponse, error) {
	out := new(AboutResponse)
	err := c.cc.Invoke(ctx, About_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AboutServer is the server API for About service.
// All implementations must embed UnimplementedAboutServer
// for forward compatibility
type AboutServer interface {
	Get(context.Context, *AboutRequest) (*AboutResponse, error)
	mustEmbedUnimplementedAboutServer()
}

// UnimplementedAboutServer must be embedded to have forward compatible implementations.
type UnimplementedAboutServer struct {
}

func (UnimplementedAboutServer) Get(context.Context, *AboutRequest) (*AboutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedAboutServer) mustEmbedUnimplementedAboutServer() {}

// UnsafeAboutServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AboutServer will
// result in compilation errors.
type UnsafeAboutServer interface {
	mustEmbedUnimplementedAboutServer()
}

func RegisterAboutServer(s grpc.ServiceRegistrar, srv AboutServer) {
	s.RegisterService(&About_ServiceDesc, srv)
}

func _About_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AboutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AboutServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: About_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AboutServer).Get(ctx, req.(*AboutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// About_ServiceDesc is the grpc.ServiceDesc for About service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var About_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "About",
	HandlerType: (*AboutServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _About_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/kvs/aerospike_proxy_kv.proto",
}

const (
	KVS_Read_FullMethodName                  = "/KVS/Read"
	KVS_ReadStreaming_FullMethodName         = "/KVS/ReadStreaming"
	KVS_GetHeader_FullMethodName             = "/KVS/GetHeader"
	KVS_GetHeaderStreaming_FullMethodName    = "/KVS/GetHeaderStreaming"
	KVS_Exists_FullMethodName                = "/KVS/Exists"
	KVS_ExistsStreaming_FullMethodName       = "/KVS/ExistsStreaming"
	KVS_Write_FullMethodName                 = "/KVS/Write"
	KVS_WriteStreaming_FullMethodName        = "/KVS/WriteStreaming"
	KVS_Delete_FullMethodName                = "/KVS/Delete"
	KVS_DeleteStreaming_FullMethodName       = "/KVS/DeleteStreaming"
	KVS_Touch_FullMethodName                 = "/KVS/Touch"
	KVS_TouchStreaming_FullMethodName        = "/KVS/TouchStreaming"
	KVS_Operate_FullMethodName               = "/KVS/Operate"
	KVS_OperateStreaming_FullMethodName      = "/KVS/OperateStreaming"
	KVS_Execute_FullMethodName               = "/KVS/Execute"
	KVS_ExecuteStreaming_FullMethodName      = "/KVS/ExecuteStreaming"
	KVS_BatchOperate_FullMethodName          = "/KVS/BatchOperate"
	KVS_BatchOperateStreaming_FullMethodName = "/KVS/BatchOperateStreaming"
)

// KVSClient is the client API for KVS service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KVSClient interface {
	// Read a single record
	Read(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (*AerospikeResponsePayload, error)
	// Process stream of single record read requests.
	ReadStreaming(ctx context.Context, opts ...grpc.CallOption) (KVS_ReadStreamingClient, error)
	// Get a single record header containing metadata like generation, expiration
	GetHeader(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (*AerospikeResponsePayload, error)
	// Process stream of single record get header requests.
	GetHeaderStreaming(ctx context.Context, opts ...grpc.CallOption) (KVS_GetHeaderStreamingClient, error)
	// Check if a record exists.
	Exists(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (*AerospikeResponsePayload, error)
	// Process stream of single record exist requests.
	ExistsStreaming(ctx context.Context, opts ...grpc.CallOption) (KVS_ExistsStreamingClient, error)
	// Write a single record
	Write(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (*AerospikeResponsePayload, error)
	// Process a stream of single record write requests.
	WriteStreaming(ctx context.Context, opts ...grpc.CallOption) (KVS_WriteStreamingClient, error)
	// Delete a single record.
	Delete(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (*AerospikeResponsePayload, error)
	// Process a stream of single record delete requests.
	DeleteStreaming(ctx context.Context, opts ...grpc.CallOption) (KVS_DeleteStreamingClient, error)
	// Reset single record's time to expiration using the write policy's expiration.
	Touch(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (*AerospikeResponsePayload, error)
	// Process a stream of single record touch requests.
	TouchStreaming(ctx context.Context, opts ...grpc.CallOption) (KVS_TouchStreamingClient, error)
	// Perform multiple read/write operations on a single key in one batch call.
	Operate(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (*AerospikeResponsePayload, error)
	// Perform a stream of operate requests.
	OperateStreaming(ctx context.Context, opts ...grpc.CallOption) (KVS_OperateStreamingClient, error)
	// Execute single key user defined function on server and return results.
	Execute(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (*AerospikeResponsePayload, error)
	// Process a stream of single record execute requests.
	ExecuteStreaming(ctx context.Context, opts ...grpc.CallOption) (KVS_ExecuteStreamingClient, error)
	// Process batch requests.
	BatchOperate(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (KVS_BatchOperateClient, error)
	// Process a stream of batch requests.
	BatchOperateStreaming(ctx context.Context, opts ...grpc.CallOption) (KVS_BatchOperateStreamingClient, error)
}

type kVSClient struct {
	cc grpc.ClientConnInterface
}

func NewKVSClient(cc grpc.ClientConnInterface) KVSClient {
	return &kVSClient{cc}
}

func (c *kVSClient) Read(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (*AerospikeResponsePayload, error) {
	out := new(AerospikeResponsePayload)
	err := c.cc.Invoke(ctx, KVS_Read_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVSClient) ReadStreaming(ctx context.Context, opts ...grpc.CallOption) (KVS_ReadStreamingClient, error) {
	stream, err := c.cc.NewStream(ctx, &KVS_ServiceDesc.Streams[0], KVS_ReadStreaming_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &kVSReadStreamingClient{stream}
	return x, nil
}

type KVS_ReadStreamingClient interface {
	Send(*AerospikeRequestPayload) error
	Recv() (*AerospikeResponsePayload, error)
	grpc.ClientStream
}

type kVSReadStreamingClient struct {
	grpc.ClientStream
}

func (x *kVSReadStreamingClient) Send(m *AerospikeRequestPayload) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kVSReadStreamingClient) Recv() (*AerospikeResponsePayload, error) {
	m := new(AerospikeResponsePayload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kVSClient) GetHeader(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (*AerospikeResponsePayload, error) {
	out := new(AerospikeResponsePayload)
	err := c.cc.Invoke(ctx, KVS_GetHeader_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVSClient) GetHeaderStreaming(ctx context.Context, opts ...grpc.CallOption) (KVS_GetHeaderStreamingClient, error) {
	stream, err := c.cc.NewStream(ctx, &KVS_ServiceDesc.Streams[1], KVS_GetHeaderStreaming_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &kVSGetHeaderStreamingClient{stream}
	return x, nil
}

type KVS_GetHeaderStreamingClient interface {
	Send(*AerospikeRequestPayload) error
	Recv() (*AerospikeResponsePayload, error)
	grpc.ClientStream
}

type kVSGetHeaderStreamingClient struct {
	grpc.ClientStream
}

func (x *kVSGetHeaderStreamingClient) Send(m *AerospikeRequestPayload) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kVSGetHeaderStreamingClient) Recv() (*AerospikeResponsePayload, error) {
	m := new(AerospikeResponsePayload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kVSClient) Exists(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (*AerospikeResponsePayload, error) {
	out := new(AerospikeResponsePayload)
	err := c.cc.Invoke(ctx, KVS_Exists_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVSClient) ExistsStreaming(ctx context.Context, opts ...grpc.CallOption) (KVS_ExistsStreamingClient, error) {
	stream, err := c.cc.NewStream(ctx, &KVS_ServiceDesc.Streams[2], KVS_ExistsStreaming_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &kVSExistsStreamingClient{stream}
	return x, nil
}

type KVS_ExistsStreamingClient interface {
	Send(*AerospikeRequestPayload) error
	Recv() (*AerospikeResponsePayload, error)
	grpc.ClientStream
}

type kVSExistsStreamingClient struct {
	grpc.ClientStream
}

func (x *kVSExistsStreamingClient) Send(m *AerospikeRequestPayload) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kVSExistsStreamingClient) Recv() (*AerospikeResponsePayload, error) {
	m := new(AerospikeResponsePayload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kVSClient) Write(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (*AerospikeResponsePayload, error) {
	out := new(AerospikeResponsePayload)
	err := c.cc.Invoke(ctx, KVS_Write_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVSClient) WriteStreaming(ctx context.Context, opts ...grpc.CallOption) (KVS_WriteStreamingClient, error) {
	stream, err := c.cc.NewStream(ctx, &KVS_ServiceDesc.Streams[3], KVS_WriteStreaming_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &kVSWriteStreamingClient{stream}
	return x, nil
}

type KVS_WriteStreamingClient interface {
	Send(*AerospikeRequestPayload) error
	Recv() (*AerospikeResponsePayload, error)
	grpc.ClientStream
}

type kVSWriteStreamingClient struct {
	grpc.ClientStream
}

func (x *kVSWriteStreamingClient) Send(m *AerospikeRequestPayload) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kVSWriteStreamingClient) Recv() (*AerospikeResponsePayload, error) {
	m := new(AerospikeResponsePayload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kVSClient) Delete(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (*AerospikeResponsePayload, error) {
	out := new(AerospikeResponsePayload)
	err := c.cc.Invoke(ctx, KVS_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVSClient) DeleteStreaming(ctx context.Context, opts ...grpc.CallOption) (KVS_DeleteStreamingClient, error) {
	stream, err := c.cc.NewStream(ctx, &KVS_ServiceDesc.Streams[4], KVS_DeleteStreaming_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &kVSDeleteStreamingClient{stream}
	return x, nil
}

type KVS_DeleteStreamingClient interface {
	Send(*AerospikeRequestPayload) error
	Recv() (*AerospikeResponsePayload, error)
	grpc.ClientStream
}

type kVSDeleteStreamingClient struct {
	grpc.ClientStream
}

func (x *kVSDeleteStreamingClient) Send(m *AerospikeRequestPayload) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kVSDeleteStreamingClient) Recv() (*AerospikeResponsePayload, error) {
	m := new(AerospikeResponsePayload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kVSClient) Touch(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (*AerospikeResponsePayload, error) {
	out := new(AerospikeResponsePayload)
	err := c.cc.Invoke(ctx, KVS_Touch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVSClient) TouchStreaming(ctx context.Context, opts ...grpc.CallOption) (KVS_TouchStreamingClient, error) {
	stream, err := c.cc.NewStream(ctx, &KVS_ServiceDesc.Streams[5], KVS_TouchStreaming_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &kVSTouchStreamingClient{stream}
	return x, nil
}

type KVS_TouchStreamingClient interface {
	Send(*AerospikeRequestPayload) error
	Recv() (*AerospikeResponsePayload, error)
	grpc.ClientStream
}

type kVSTouchStreamingClient struct {
	grpc.ClientStream
}

func (x *kVSTouchStreamingClient) Send(m *AerospikeRequestPayload) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kVSTouchStreamingClient) Recv() (*AerospikeResponsePayload, error) {
	m := new(AerospikeResponsePayload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kVSClient) Operate(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (*AerospikeResponsePayload, error) {
	out := new(AerospikeResponsePayload)
	err := c.cc.Invoke(ctx, KVS_Operate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVSClient) OperateStreaming(ctx context.Context, opts ...grpc.CallOption) (KVS_OperateStreamingClient, error) {
	stream, err := c.cc.NewStream(ctx, &KVS_ServiceDesc.Streams[6], KVS_OperateStreaming_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &kVSOperateStreamingClient{stream}
	return x, nil
}

type KVS_OperateStreamingClient interface {
	Send(*AerospikeRequestPayload) error
	Recv() (*AerospikeResponsePayload, error)
	grpc.ClientStream
}

type kVSOperateStreamingClient struct {
	grpc.ClientStream
}

func (x *kVSOperateStreamingClient) Send(m *AerospikeRequestPayload) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kVSOperateStreamingClient) Recv() (*AerospikeResponsePayload, error) {
	m := new(AerospikeResponsePayload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kVSClient) Execute(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (*AerospikeResponsePayload, error) {
	out := new(AerospikeResponsePayload)
	err := c.cc.Invoke(ctx, KVS_Execute_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVSClient) ExecuteStreaming(ctx context.Context, opts ...grpc.CallOption) (KVS_ExecuteStreamingClient, error) {
	stream, err := c.cc.NewStream(ctx, &KVS_ServiceDesc.Streams[7], KVS_ExecuteStreaming_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &kVSExecuteStreamingClient{stream}
	return x, nil
}

type KVS_ExecuteStreamingClient interface {
	Send(*AerospikeRequestPayload) error
	Recv() (*AerospikeResponsePayload, error)
	grpc.ClientStream
}

type kVSExecuteStreamingClient struct {
	grpc.ClientStream
}

func (x *kVSExecuteStreamingClient) Send(m *AerospikeRequestPayload) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kVSExecuteStreamingClient) Recv() (*AerospikeResponsePayload, error) {
	m := new(AerospikeResponsePayload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kVSClient) BatchOperate(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (KVS_BatchOperateClient, error) {
	stream, err := c.cc.NewStream(ctx, &KVS_ServiceDesc.Streams[8], KVS_BatchOperate_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &kVSBatchOperateClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type KVS_BatchOperateClient interface {
	Recv() (*AerospikeResponsePayload, error)
	grpc.ClientStream
}

type kVSBatchOperateClient struct {
	grpc.ClientStream
}

func (x *kVSBatchOperateClient) Recv() (*AerospikeResponsePayload, error) {
	m := new(AerospikeResponsePayload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kVSClient) BatchOperateStreaming(ctx context.Context, opts ...grpc.CallOption) (KVS_BatchOperateStreamingClient, error) {
	stream, err := c.cc.NewStream(ctx, &KVS_ServiceDesc.Streams[9], KVS_BatchOperateStreaming_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &kVSBatchOperateStreamingClient{stream}
	return x, nil
}

type KVS_BatchOperateStreamingClient interface {
	Send(*AerospikeRequestPayload) error
	Recv() (*AerospikeResponsePayload, error)
	grpc.ClientStream
}

type kVSBatchOperateStreamingClient struct {
	grpc.ClientStream
}

func (x *kVSBatchOperateStreamingClient) Send(m *AerospikeRequestPayload) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kVSBatchOperateStreamingClient) Recv() (*AerospikeResponsePayload, error) {
	m := new(AerospikeResponsePayload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// KVSServer is the server API for KVS service.
// All implementations must embed UnimplementedKVSServer
// for forward compatibility
type KVSServer interface {
	// Read a single record
	Read(context.Context, *AerospikeRequestPayload) (*AerospikeResponsePayload, error)
	// Process stream of single record read requests.
	ReadStreaming(KVS_ReadStreamingServer) error
	// Get a single record header containing metadata like generation, expiration
	GetHeader(context.Context, *AerospikeRequestPayload) (*AerospikeResponsePayload, error)
	// Process stream of single record get header requests.
	GetHeaderStreaming(KVS_GetHeaderStreamingServer) error
	// Check if a record exists.
	Exists(context.Context, *AerospikeRequestPayload) (*AerospikeResponsePayload, error)
	// Process stream of single record exist requests.
	ExistsStreaming(KVS_ExistsStreamingServer) error
	// Write a single record
	Write(context.Context, *AerospikeRequestPayload) (*AerospikeResponsePayload, error)
	// Process a stream of single record write requests.
	WriteStreaming(KVS_WriteStreamingServer) error
	// Delete a single record.
	Delete(context.Context, *AerospikeRequestPayload) (*AerospikeResponsePayload, error)
	// Process a stream of single record delete requests.
	DeleteStreaming(KVS_DeleteStreamingServer) error
	// Reset single record's time to expiration using the write policy's expiration.
	Touch(context.Context, *AerospikeRequestPayload) (*AerospikeResponsePayload, error)
	// Process a stream of single record touch requests.
	TouchStreaming(KVS_TouchStreamingServer) error
	// Perform multiple read/write operations on a single key in one batch call.
	Operate(context.Context, *AerospikeRequestPayload) (*AerospikeResponsePayload, error)
	// Perform a stream of operate requests.
	OperateStreaming(KVS_OperateStreamingServer) error
	// Execute single key user defined function on server and return results.
	Execute(context.Context, *AerospikeRequestPayload) (*AerospikeResponsePayload, error)
	// Process a stream of single record execute requests.
	ExecuteStreaming(KVS_ExecuteStreamingServer) error
	// Process batch requests.
	BatchOperate(*AerospikeRequestPayload, KVS_BatchOperateServer) error
	// Process a stream of batch requests.
	BatchOperateStreaming(KVS_BatchOperateStreamingServer) error
	mustEmbedUnimplementedKVSServer()
}

// UnimplementedKVSServer must be embedded to have forward compatible implementations.
type UnimplementedKVSServer struct {
}

func (UnimplementedKVSServer) Read(context.Context, *AerospikeRequestPayload) (*AerospikeResponsePayload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (UnimplementedKVSServer) ReadStreaming(KVS_ReadStreamingServer) error {
	return status.Errorf(codes.Unimplemented, "method ReadStreaming not implemented")
}
func (UnimplementedKVSServer) GetHeader(context.Context, *AerospikeRequestPayload) (*AerospikeResponsePayload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHeader not implemented")
}
func (UnimplementedKVSServer) GetHeaderStreaming(KVS_GetHeaderStreamingServer) error {
	return status.Errorf(codes.Unimplemented, "method GetHeaderStreaming not implemented")
}
func (UnimplementedKVSServer) Exists(context.Context, *AerospikeRequestPayload) (*AerospikeResponsePayload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Exists not implemented")
}
func (UnimplementedKVSServer) ExistsStreaming(KVS_ExistsStreamingServer) error {
	return status.Errorf(codes.Unimplemented, "method ExistsStreaming not implemented")
}
func (UnimplementedKVSServer) Write(context.Context, *AerospikeRequestPayload) (*AerospikeResponsePayload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Write not implemented")
}
func (UnimplementedKVSServer) WriteStreaming(KVS_WriteStreamingServer) error {
	return status.Errorf(codes.Unimplemented, "method WriteStreaming not implemented")
}
func (UnimplementedKVSServer) Delete(context.Context, *AerospikeRequestPayload) (*AerospikeResponsePayload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedKVSServer) DeleteStreaming(KVS_DeleteStreamingServer) error {
	return status.Errorf(codes.Unimplemented, "method DeleteStreaming not implemented")
}
func (UnimplementedKVSServer) Touch(context.Context, *AerospikeRequestPayload) (*AerospikeResponsePayload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Touch not implemented")
}
func (UnimplementedKVSServer) TouchStreaming(KVS_TouchStreamingServer) error {
	return status.Errorf(codes.Unimplemented, "method TouchStreaming not implemented")
}
func (UnimplementedKVSServer) Operate(context.Context, *AerospikeRequestPayload) (*AerospikeResponsePayload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Operate not implemented")
}
func (UnimplementedKVSServer) OperateStreaming(KVS_OperateStreamingServer) error {
	return status.Errorf(codes.Unimplemented, "method OperateStreaming not implemented")
}
func (UnimplementedKVSServer) Execute(context.Context, *AerospikeRequestPayload) (*AerospikeResponsePayload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Execute not implemented")
}
func (UnimplementedKVSServer) ExecuteStreaming(KVS_ExecuteStreamingServer) error {
	return status.Errorf(codes.Unimplemented, "method ExecuteStreaming not implemented")
}
func (UnimplementedKVSServer) BatchOperate(*AerospikeRequestPayload, KVS_BatchOperateServer) error {
	return status.Errorf(codes.Unimplemented, "method BatchOperate not implemented")
}
func (UnimplementedKVSServer) BatchOperateStreaming(KVS_BatchOperateStreamingServer) error {
	return status.Errorf(codes.Unimplemented, "method BatchOperateStreaming not implemented")
}
func (UnimplementedKVSServer) mustEmbedUnimplementedKVSServer() {}

// UnsafeKVSServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KVSServer will
// result in compilation errors.
type UnsafeKVSServer interface {
	mustEmbedUnimplementedKVSServer()
}

func RegisterKVSServer(s grpc.ServiceRegistrar, srv KVSServer) {
	s.RegisterService(&KVS_ServiceDesc, srv)
}

func _KVS_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AerospikeRequestPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVSServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KVS_Read_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVSServer).Read(ctx, req.(*AerospikeRequestPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVS_ReadStreaming_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KVSServer).ReadStreaming(&kVSReadStreamingServer{stream})
}

type KVS_ReadStreamingServer interface {
	Send(*AerospikeResponsePayload) error
	Recv() (*AerospikeRequestPayload, error)
	grpc.ServerStream
}

type kVSReadStreamingServer struct {
	grpc.ServerStream
}

func (x *kVSReadStreamingServer) Send(m *AerospikeResponsePayload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kVSReadStreamingServer) Recv() (*AerospikeRequestPayload, error) {
	m := new(AerospikeRequestPayload)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KVS_GetHeader_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AerospikeRequestPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVSServer).GetHeader(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KVS_GetHeader_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVSServer).GetHeader(ctx, req.(*AerospikeRequestPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVS_GetHeaderStreaming_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KVSServer).GetHeaderStreaming(&kVSGetHeaderStreamingServer{stream})
}

type KVS_GetHeaderStreamingServer interface {
	Send(*AerospikeResponsePayload) error
	Recv() (*AerospikeRequestPayload, error)
	grpc.ServerStream
}

type kVSGetHeaderStreamingServer struct {
	grpc.ServerStream
}

func (x *kVSGetHeaderStreamingServer) Send(m *AerospikeResponsePayload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kVSGetHeaderStreamingServer) Recv() (*AerospikeRequestPayload, error) {
	m := new(AerospikeRequestPayload)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KVS_Exists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AerospikeRequestPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVSServer).Exists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KVS_Exists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVSServer).Exists(ctx, req.(*AerospikeRequestPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVS_ExistsStreaming_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KVSServer).ExistsStreaming(&kVSExistsStreamingServer{stream})
}

type KVS_ExistsStreamingServer interface {
	Send(*AerospikeResponsePayload) error
	Recv() (*AerospikeRequestPayload, error)
	grpc.ServerStream
}

type kVSExistsStreamingServer struct {
	grpc.ServerStream
}

func (x *kVSExistsStreamingServer) Send(m *AerospikeResponsePayload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kVSExistsStreamingServer) Recv() (*AerospikeRequestPayload, error) {
	m := new(AerospikeRequestPayload)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KVS_Write_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AerospikeRequestPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVSServer).Write(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KVS_Write_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVSServer).Write(ctx, req.(*AerospikeRequestPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVS_WriteStreaming_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KVSServer).WriteStreaming(&kVSWriteStreamingServer{stream})
}

type KVS_WriteStreamingServer interface {
	Send(*AerospikeResponsePayload) error
	Recv() (*AerospikeRequestPayload, error)
	grpc.ServerStream
}

type kVSWriteStreamingServer struct {
	grpc.ServerStream
}

func (x *kVSWriteStreamingServer) Send(m *AerospikeResponsePayload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kVSWriteStreamingServer) Recv() (*AerospikeRequestPayload, error) {
	m := new(AerospikeRequestPayload)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KVS_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AerospikeRequestPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVSServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KVS_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVSServer).Delete(ctx, req.(*AerospikeRequestPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVS_DeleteStreaming_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KVSServer).DeleteStreaming(&kVSDeleteStreamingServer{stream})
}

type KVS_DeleteStreamingServer interface {
	Send(*AerospikeResponsePayload) error
	Recv() (*AerospikeRequestPayload, error)
	grpc.ServerStream
}

type kVSDeleteStreamingServer struct {
	grpc.ServerStream
}

func (x *kVSDeleteStreamingServer) Send(m *AerospikeResponsePayload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kVSDeleteStreamingServer) Recv() (*AerospikeRequestPayload, error) {
	m := new(AerospikeRequestPayload)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KVS_Touch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AerospikeRequestPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVSServer).Touch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KVS_Touch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVSServer).Touch(ctx, req.(*AerospikeRequestPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVS_TouchStreaming_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KVSServer).TouchStreaming(&kVSTouchStreamingServer{stream})
}

type KVS_TouchStreamingServer interface {
	Send(*AerospikeResponsePayload) error
	Recv() (*AerospikeRequestPayload, error)
	grpc.ServerStream
}

type kVSTouchStreamingServer struct {
	grpc.ServerStream
}

func (x *kVSTouchStreamingServer) Send(m *AerospikeResponsePayload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kVSTouchStreamingServer) Recv() (*AerospikeRequestPayload, error) {
	m := new(AerospikeRequestPayload)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KVS_Operate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AerospikeRequestPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVSServer).Operate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KVS_Operate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVSServer).Operate(ctx, req.(*AerospikeRequestPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVS_OperateStreaming_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KVSServer).OperateStreaming(&kVSOperateStreamingServer{stream})
}

type KVS_OperateStreamingServer interface {
	Send(*AerospikeResponsePayload) error
	Recv() (*AerospikeRequestPayload, error)
	grpc.ServerStream
}

type kVSOperateStreamingServer struct {
	grpc.ServerStream
}

func (x *kVSOperateStreamingServer) Send(m *AerospikeResponsePayload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kVSOperateStreamingServer) Recv() (*AerospikeRequestPayload, error) {
	m := new(AerospikeRequestPayload)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KVS_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AerospikeRequestPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVSServer).Execute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KVS_Execute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVSServer).Execute(ctx, req.(*AerospikeRequestPayload))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVS_ExecuteStreaming_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KVSServer).ExecuteStreaming(&kVSExecuteStreamingServer{stream})
}

type KVS_ExecuteStreamingServer interface {
	Send(*AerospikeResponsePayload) error
	Recv() (*AerospikeRequestPayload, error)
	grpc.ServerStream
}

type kVSExecuteStreamingServer struct {
	grpc.ServerStream
}

func (x *kVSExecuteStreamingServer) Send(m *AerospikeResponsePayload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kVSExecuteStreamingServer) Recv() (*AerospikeRequestPayload, error) {
	m := new(AerospikeRequestPayload)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KVS_BatchOperate_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AerospikeRequestPayload)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KVSServer).BatchOperate(m, &kVSBatchOperateServer{stream})
}

type KVS_BatchOperateServer interface {
	Send(*AerospikeResponsePayload) error
	grpc.ServerStream
}

type kVSBatchOperateServer struct {
	grpc.ServerStream
}

func (x *kVSBatchOperateServer) Send(m *AerospikeResponsePayload) error {
	return x.ServerStream.SendMsg(m)
}

func _KVS_BatchOperateStreaming_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KVSServer).BatchOperateStreaming(&kVSBatchOperateStreamingServer{stream})
}

type KVS_BatchOperateStreamingServer interface {
	Send(*AerospikeResponsePayload) error
	Recv() (*AerospikeRequestPayload, error)
	grpc.ServerStream
}

type kVSBatchOperateStreamingServer struct {
	grpc.ServerStream
}

func (x *kVSBatchOperateStreamingServer) Send(m *AerospikeResponsePayload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kVSBatchOperateStreamingServer) Recv() (*AerospikeRequestPayload, error) {
	m := new(AerospikeRequestPayload)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// KVS_ServiceDesc is the grpc.ServiceDesc for KVS service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KVS_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "KVS",
	HandlerType: (*KVSServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Read",
			Handler:    _KVS_Read_Handler,
		},
		{
			MethodName: "GetHeader",
			Handler:    _KVS_GetHeader_Handler,
		},
		{
			MethodName: "Exists",
			Handler:    _KVS_Exists_Handler,
		},
		{
			MethodName: "Write",
			Handler:    _KVS_Write_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _KVS_Delete_Handler,
		},
		{
			MethodName: "Touch",
			Handler:    _KVS_Touch_Handler,
		},
		{
			MethodName: "Operate",
			Handler:    _KVS_Operate_Handler,
		},
		{
			MethodName: "Execute",
			Handler:    _KVS_Execute_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ReadStreaming",
			Handler:       _KVS_ReadStreaming_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "GetHeaderStreaming",
			Handler:       _KVS_GetHeaderStreaming_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "ExistsStreaming",
			Handler:       _KVS_ExistsStreaming_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "WriteStreaming",
			Handler:       _KVS_WriteStreaming_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DeleteStreaming",
			Handler:       _KVS_DeleteStreaming_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "TouchStreaming",
			Handler:       _KVS_TouchStreaming_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "OperateStreaming",
			Handler:       _KVS_OperateStreaming_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "ExecuteStreaming",
			Handler:       _KVS_ExecuteStreaming_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "BatchOperate",
			Handler:       _KVS_BatchOperate_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "BatchOperateStreaming",
			Handler:       _KVS_BatchOperateStreaming_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "proto/kvs/aerospike_proxy_kv.proto",
}

const (
	Scan_Scan_FullMethodName          = "/Scan/Scan"
	Scan_ScanStreaming_FullMethodName = "/Scan/ScanStreaming"
)

// ScanClient is the client API for Scan service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ScanClient interface {
	// Scan Aerospike
	Scan(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (Scan_ScanClient, error)
	// Process a stream of scan requests
	ScanStreaming(ctx context.Context, opts ...grpc.CallOption) (Scan_ScanStreamingClient, error)
}

type scanClient struct {
	cc grpc.ClientConnInterface
}

func NewScanClient(cc grpc.ClientConnInterface) ScanClient {
	return &scanClient{cc}
}

func (c *scanClient) Scan(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (Scan_ScanClient, error) {
	stream, err := c.cc.NewStream(ctx, &Scan_ServiceDesc.Streams[0], Scan_Scan_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &scanScanClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Scan_ScanClient interface {
	Recv() (*AerospikeResponsePayload, error)
	grpc.ClientStream
}

type scanScanClient struct {
	grpc.ClientStream
}

func (x *scanScanClient) Recv() (*AerospikeResponsePayload, error) {
	m := new(AerospikeResponsePayload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *scanClient) ScanStreaming(ctx context.Context, opts ...grpc.CallOption) (Scan_ScanStreamingClient, error) {
	stream, err := c.cc.NewStream(ctx, &Scan_ServiceDesc.Streams[1], Scan_ScanStreaming_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &scanScanStreamingClient{stream}
	return x, nil
}

type Scan_ScanStreamingClient interface {
	Send(*AerospikeRequestPayload) error
	Recv() (*AerospikeResponsePayload, error)
	grpc.ClientStream
}

type scanScanStreamingClient struct {
	grpc.ClientStream
}

func (x *scanScanStreamingClient) Send(m *AerospikeRequestPayload) error {
	return x.ClientStream.SendMsg(m)
}

func (x *scanScanStreamingClient) Recv() (*AerospikeResponsePayload, error) {
	m := new(AerospikeResponsePayload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ScanServer is the server API for Scan service.
// All implementations must embed UnimplementedScanServer
// for forward compatibility
type ScanServer interface {
	// Scan Aerospike
	Scan(*AerospikeRequestPayload, Scan_ScanServer) error
	// Process a stream of scan requests
	ScanStreaming(Scan_ScanStreamingServer) error
	mustEmbedUnimplementedScanServer()
}

// UnimplementedScanServer must be embedded to have forward compatible implementations.
type UnimplementedScanServer struct {
}

func (UnimplementedScanServer) Scan(*AerospikeRequestPayload, Scan_ScanServer) error {
	return status.Errorf(codes.Unimplemented, "method Scan not implemented")
}
func (UnimplementedScanServer) ScanStreaming(Scan_ScanStreamingServer) error {
	return status.Errorf(codes.Unimplemented, "method ScanStreaming not implemented")
}
func (UnimplementedScanServer) mustEmbedUnimplementedScanServer() {}

// UnsafeScanServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ScanServer will
// result in compilation errors.
type UnsafeScanServer interface {
	mustEmbedUnimplementedScanServer()
}

func RegisterScanServer(s grpc.ServiceRegistrar, srv ScanServer) {
	s.RegisterService(&Scan_ServiceDesc, srv)
}

func _Scan_Scan_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AerospikeRequestPayload)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ScanServer).Scan(m, &scanScanServer{stream})
}

type Scan_ScanServer interface {
	Send(*AerospikeResponsePayload) error
	grpc.ServerStream
}

type scanScanServer struct {
	grpc.ServerStream
}

func (x *scanScanServer) Send(m *AerospikeResponsePayload) error {
	return x.ServerStream.SendMsg(m)
}

func _Scan_ScanStreaming_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ScanServer).ScanStreaming(&scanScanStreamingServer{stream})
}

type Scan_ScanStreamingServer interface {
	Send(*AerospikeResponsePayload) error
	Recv() (*AerospikeRequestPayload, error)
	grpc.ServerStream
}

type scanScanStreamingServer struct {
	grpc.ServerStream
}

func (x *scanScanStreamingServer) Send(m *AerospikeResponsePayload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *scanScanStreamingServer) Recv() (*AerospikeRequestPayload, error) {
	m := new(AerospikeRequestPayload)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Scan_ServiceDesc is the grpc.ServiceDesc for Scan service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Scan_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Scan",
	HandlerType: (*ScanServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Scan",
			Handler:       _Scan_Scan_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ScanStreaming",
			Handler:       _Scan_ScanStreaming_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "proto/kvs/aerospike_proxy_kv.proto",
}

const (
	Query_Query_FullMethodName                         = "/Query/Query"
	Query_QueryStreaming_FullMethodName                = "/Query/QueryStreaming"
	Query_BackgroundExecute_FullMethodName             = "/Query/BackgroundExecute"
	Query_BackgroundExecuteStreaming_FullMethodName    = "/Query/BackgroundExecuteStreaming"
	Query_BackgroundTaskStatus_FullMethodName          = "/Query/BackgroundTaskStatus"
	Query_BackgroundTaskStatusStreaming_FullMethodName = "/Query/BackgroundTaskStatusStreaming"
)

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QueryClient interface {
	// Query Aerospike
	Query(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (Query_QueryClient, error)
	// Process a stream of query requests
	QueryStreaming(ctx context.Context, opts ...grpc.CallOption) (Query_QueryStreamingClient, error)
	// Execute background write on selected records.
	BackgroundExecute(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (Query_BackgroundExecuteClient, error)
	// Execute a stream of  background write requests.
	BackgroundExecuteStreaming(ctx context.Context, opts ...grpc.CallOption) (Query_BackgroundExecuteStreamingClient, error)
	// Get status of a background task.
	BackgroundTaskStatus(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (Query_BackgroundTaskStatusClient, error)
	// Get status of a stream of background tasks.
	BackgroundTaskStatusStreaming(ctx context.Context, opts ...grpc.CallOption) (Query_BackgroundTaskStatusStreamingClient, error)
}

type queryClient struct {
	cc grpc.ClientConnInterface
}

func NewQueryClient(cc grpc.ClientConnInterface) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) Query(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (Query_QueryClient, error) {
	stream, err := c.cc.NewStream(ctx, &Query_ServiceDesc.Streams[0], Query_Query_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &queryQueryClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_QueryClient interface {
	Recv() (*AerospikeResponsePayload, error)
	grpc.ClientStream
}

type queryQueryClient struct {
	grpc.ClientStream
}

func (x *queryQueryClient) Recv() (*AerospikeResponsePayload, error) {
	m := new(AerospikeResponsePayload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryClient) QueryStreaming(ctx context.Context, opts ...grpc.CallOption) (Query_QueryStreamingClient, error) {
	stream, err := c.cc.NewStream(ctx, &Query_ServiceDesc.Streams[1], Query_QueryStreaming_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &queryQueryStreamingClient{stream}
	return x, nil
}

type Query_QueryStreamingClient interface {
	Send(*AerospikeRequestPayload) error
	Recv() (*AerospikeResponsePayload, error)
	grpc.ClientStream
}

type queryQueryStreamingClient struct {
	grpc.ClientStream
}

func (x *queryQueryStreamingClient) Send(m *AerospikeRequestPayload) error {
	return x.ClientStream.SendMsg(m)
}

func (x *queryQueryStreamingClient) Recv() (*AerospikeResponsePayload, error) {
	m := new(AerospikeResponsePayload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryClient) BackgroundExecute(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (Query_BackgroundExecuteClient, error) {
	stream, err := c.cc.NewStream(ctx, &Query_ServiceDesc.Streams[2], Query_BackgroundExecute_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &queryBackgroundExecuteClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_BackgroundExecuteClient interface {
	Recv() (*AerospikeResponsePayload, error)
	grpc.ClientStream
}

type queryBackgroundExecuteClient struct {
	grpc.ClientStream
}

func (x *queryBackgroundExecuteClient) Recv() (*AerospikeResponsePayload, error) {
	m := new(AerospikeResponsePayload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryClient) BackgroundExecuteStreaming(ctx context.Context, opts ...grpc.CallOption) (Query_BackgroundExecuteStreamingClient, error) {
	stream, err := c.cc.NewStream(ctx, &Query_ServiceDesc.Streams[3], Query_BackgroundExecuteStreaming_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &queryBackgroundExecuteStreamingClient{stream}
	return x, nil
}

type Query_BackgroundExecuteStreamingClient interface {
	Send(*AerospikeRequestPayload) error
	Recv() (*AerospikeResponsePayload, error)
	grpc.ClientStream
}

type queryBackgroundExecuteStreamingClient struct {
	grpc.ClientStream
}

func (x *queryBackgroundExecuteStreamingClient) Send(m *AerospikeRequestPayload) error {
	return x.ClientStream.SendMsg(m)
}

func (x *queryBackgroundExecuteStreamingClient) Recv() (*AerospikeResponsePayload, error) {
	m := new(AerospikeResponsePayload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryClient) BackgroundTaskStatus(ctx context.Context, in *AerospikeRequestPayload, opts ...grpc.CallOption) (Query_BackgroundTaskStatusClient, error) {
	stream, err := c.cc.NewStream(ctx, &Query_ServiceDesc.Streams[4], Query_BackgroundTaskStatus_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &queryBackgroundTaskStatusClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_BackgroundTaskStatusClient interface {
	Recv() (*AerospikeResponsePayload, error)
	grpc.ClientStream
}

type queryBackgroundTaskStatusClient struct {
	grpc.ClientStream
}

func (x *queryBackgroundTaskStatusClient) Recv() (*AerospikeResponsePayload, error) {
	m := new(AerospikeResponsePayload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryClient) BackgroundTaskStatusStreaming(ctx context.Context, opts ...grpc.CallOption) (Query_BackgroundTaskStatusStreamingClient, error) {
	stream, err := c.cc.NewStream(ctx, &Query_ServiceDesc.Streams[5], Query_BackgroundTaskStatusStreaming_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &queryBackgroundTaskStatusStreamingClient{stream}
	return x, nil
}

type Query_BackgroundTaskStatusStreamingClient interface {
	Send(*AerospikeRequestPayload) error
	Recv() (*AerospikeResponsePayload, error)
	grpc.ClientStream
}

type queryBackgroundTaskStatusStreamingClient struct {
	grpc.ClientStream
}

func (x *queryBackgroundTaskStatusStreamingClient) Send(m *AerospikeRequestPayload) error {
	return x.ClientStream.SendMsg(m)
}

func (x *queryBackgroundTaskStatusStreamingClient) Recv() (*AerospikeResponsePayload, error) {
	m := new(AerospikeResponsePayload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// QueryServer is the server API for Query service.
// All implementations must embed UnimplementedQueryServer
// for forward compatibility
type QueryServer interface {
	// Query Aerospike
	Query(*AerospikeRequestPayload, Query_QueryServer) error
	// Process a stream of query requests
	QueryStreaming(Query_QueryStreamingServer) error
	// Execute background write on selected records.
	BackgroundExecute(*AerospikeRequestPayload, Query_BackgroundExecuteServer) error
	// Execute a stream of  background write requests.
	BackgroundExecuteStreaming(Query_BackgroundExecuteStreamingServer) error
	// Get status of a background task.
	BackgroundTaskStatus(*AerospikeRequestPayload, Query_BackgroundTaskStatusServer) error
	// Get status of a stream of background tasks.
	BackgroundTaskStatusStreaming(Query_BackgroundTaskStatusStreamingServer) error
	mustEmbedUnimplementedQueryServer()
}

// UnimplementedQueryServer must be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (UnimplementedQueryServer) Query(*AerospikeRequestPayload, Query_QueryServer) error {
	return status.Errorf(codes.Unimplemented, "method Query not implemented")
}
func (UnimplementedQueryServer) QueryStreaming(Query_QueryStreamingServer) error {
	return status.Errorf(codes.Unimplemented, "method QueryStreaming not implemented")
}
func (UnimplementedQueryServer) BackgroundExecute(*AerospikeRequestPayload, Query_BackgroundExecuteServer) error {
	return status.Errorf(codes.Unimplemented, "method BackgroundExecute not implemented")
}
func (UnimplementedQueryServer) BackgroundExecuteStreaming(Query_BackgroundExecuteStreamingServer) error {
	return status.Errorf(codes.Unimplemented, "method BackgroundExecuteStreaming not implemented")
}
func (UnimplementedQueryServer) BackgroundTaskStatus(*AerospikeRequestPayload, Query_BackgroundTaskStatusServer) error {
	return status.Errorf(codes.Unimplemented, "method BackgroundTaskStatus not implemented")
}
func (UnimplementedQueryServer) BackgroundTaskStatusStreaming(Query_BackgroundTaskStatusStreamingServer) error {
	return status.Errorf(codes.Unimplemented, "method BackgroundTaskStatusStreaming not implemented")
}
func (UnimplementedQueryServer) mustEmbedUnimplementedQueryServer() {}

// UnsafeQueryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QueryServer will
// result in compilation errors.
type UnsafeQueryServer interface {
	mustEmbedUnimplementedQueryServer()
}

func RegisterQueryServer(s grpc.ServiceRegistrar, srv QueryServer) {
	s.RegisterService(&Query_ServiceDesc, srv)
}

func _Query_Query_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AerospikeRequestPayload)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).Query(m, &queryQueryServer{stream})
}

type Query_QueryServer interface {
	Send(*AerospikeResponsePayload) error
	grpc.ServerStream
}

type queryQueryServer struct {
	grpc.ServerStream
}

func (x *queryQueryServer) Send(m *AerospikeResponsePayload) error {
	return x.ServerStream.SendMsg(m)
}

func _Query_QueryStreaming_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(QueryServer).QueryStreaming(&queryQueryStreamingServer{stream})
}

type Query_QueryStreamingServer interface {
	Send(*AerospikeResponsePayload) error
	Recv() (*AerospikeRequestPayload, error)
	grpc.ServerStream
}

type queryQueryStreamingServer struct {
	grpc.ServerStream
}

func (x *queryQueryStreamingServer) Send(m *AerospikeResponsePayload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *queryQueryStreamingServer) Recv() (*AerospikeRequestPayload, error) {
	m := new(AerospikeRequestPayload)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Query_BackgroundExecute_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AerospikeRequestPayload)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).BackgroundExecute(m, &queryBackgroundExecuteServer{stream})
}

type Query_BackgroundExecuteServer interface {
	Send(*AerospikeResponsePayload) error
	grpc.ServerStream
}

type queryBackgroundExecuteServer struct {
	grpc.ServerStream
}

func (x *queryBackgroundExecuteServer) Send(m *AerospikeResponsePayload) error {
	return x.ServerStream.SendMsg(m)
}

func _Query_BackgroundExecuteStreaming_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(QueryServer).BackgroundExecuteStreaming(&queryBackgroundExecuteStreamingServer{stream})
}

type Query_BackgroundExecuteStreamingServer interface {
	Send(*AerospikeResponsePayload) error
	Recv() (*AerospikeRequestPayload, error)
	grpc.ServerStream
}

type queryBackgroundExecuteStreamingServer struct {
	grpc.ServerStream
}

func (x *queryBackgroundExecuteStreamingServer) Send(m *AerospikeResponsePayload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *queryBackgroundExecuteStreamingServer) Recv() (*AerospikeRequestPayload, error) {
	m := new(AerospikeRequestPayload)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Query_BackgroundTaskStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AerospikeRequestPayload)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).BackgroundTaskStatus(m, &queryBackgroundTaskStatusServer{stream})
}

type Query_BackgroundTaskStatusServer interface {
	Send(*AerospikeResponsePayload) error
	grpc.ServerStream
}

type queryBackgroundTaskStatusServer struct {
	grpc.ServerStream
}

func (x *queryBackgroundTaskStatusServer) Send(m *AerospikeResponsePayload) error {
	return x.ServerStream.SendMsg(m)
}

func _Query_BackgroundTaskStatusStreaming_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(QueryServer).BackgroundTaskStatusStreaming(&queryBackgroundTaskStatusStreamingServer{stream})
}

type Query_BackgroundTaskStatusStreamingServer interface {
	Send(*AerospikeResponsePayload) error
	Recv() (*AerospikeRequestPayload, error)
	grpc.ServerStream
}

type queryBackgroundTaskStatusStreamingServer struct {
	grpc.ServerStream
}

func (x *queryBackgroundTaskStatusStreamingServer) Send(m *AerospikeResponsePayload) error {
	return x.ServerStream.SendMsg(m)
}

func (x *queryBackgroundTaskStatusStreamingServer) Recv() (*AerospikeRequestPayload, error) {
	m := new(AerospikeRequestPayload)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Query_ServiceDesc is the grpc.ServiceDesc for Query service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Query_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Query",
	HandlerType: (*QueryServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Query",
			Handler:       _Query_Query_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "QueryStreaming",
			Handler:       _Query_QueryStreaming_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "BackgroundExecute",
			Handler:       _Query_BackgroundExecute_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "BackgroundExecuteStreaming",
			Handler:       _Query_BackgroundExecuteStreaming_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "BackgroundTaskStatus",
			Handler:       _Query_BackgroundTaskStatus_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "BackgroundTaskStatusStreaming",
			Handler:       _Query_BackgroundTaskStatusStreaming_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "proto/kvs/aerospike_proxy_kv.proto",
}
